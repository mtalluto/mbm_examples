trDissE <- merge(trDiss, envMat)
trMPD <- melt(trMPD, varnames=c('site1', 'site2'), value.name = tr)
trMPDE <- merge(trMPD, envMat)
plot(trDissE[,'distance'], trDissE[,tr], pch=20, cex=0.5, main=paste0(tr, '-Dissim'))
lines(predict(loess(trDissE[,tr] ~ trDissE[,'distance'])), col='blue', lwd=1.5)
plot(trMPDE[,'distance'], trMPDE[,tr], pch=20, cex=0.5, main=paste0(tr, '-MPD'))
lines(predict(loess(trMPDE[,tr] ~ trMPDE[,'distance'])), col='blue', lwd=1.5)
}
dim(trDiss)
head(trDiss)
head(trDissE)
nrow(trDiss)
nrow(trDissE)
pdf("~/Desktop/plot.pdf")
par(mfrow=c(5,2))
for(tr in colnames(alps$spTrait)) {
cat(tr, '\n')
trMat <- alps$spTrait[,tr,drop=FALSE]
trMat <- trMat[complete.cases(trMat),,drop=FALSE]
comm <- alps$siteSpecies[rows[[1]],which(colnames(alps$siteSpecies) %in% rownames(trMat))]
trMat <- trMat[which(rownames(trMat) %in% colnames(comm)),, drop=FALSE]
fDist <- as.matrix(dist(trMat))
trDiss <- matrix(nrow=nrow(comm), ncol=ncol(comm))
dimnames(trDiss) <- dimnames(comm)
b <- apply(comm, 1, function(x) {
x <- x/sum(x)
sum(outer(x,x) * fDist)
})
for(i in 2:nrow(trDiss)) {
cat(i,'.')
for(j in 1:(i-1)) {
trDiss[i,j] <- rao(comm[i,], comm[j,], b[i], b[j], fDist)
}
trMPD <- mpd(comm, dis=fDist)
trDiss <- melt(trDiss, varnames=c('site1', 'site2'), value.name = tr)
trDissE <- merge(trDiss, envMat)
trMPD <- melt(trMPD, varnames=c('site1', 'site2'), value.name = tr)
trMPDE <- merge(trMPD, envMat)
plot(trDissE[,'distance'], trDissE[,tr], pch=20, cex=0.5, main=paste0(tr, '-Dissim'))
lines(predict(loess(trDissE[,tr] ~ trDissE[,'distance'])), col='blue', lwd=1.5)
plot(trMPDE[,'distance'], trMPDE[,tr], pch=20, cex=0.5, main=paste0(tr, '-MPD'))
lines(predict(loess(trMPDE[,tr] ~ trMPDE[,'distance'])), col='blue', lwd=1.5)
}
library(parallel)
trdivE <- mclapply(colnames(alps$spTrait) function(tr) {
trMat <- alps$spTrait[,tr,drop=FALSE]
trMat <- trMat[complete.cases(trMat),,drop=FALSE]
comm <- alps$siteSpecies[rows[[1]],which(colnames(alps$siteSpecies) %in% rownames(trMat))]
trMat <- trMat[which(rownames(trMat) %in% colnames(comm)),, drop=FALSE]
fDist <- as.matrix(dist(trMat))
trDiss <- matrix(nrow=nrow(comm), ncol=ncol(comm))
dimnames(trDiss) <- dimnames(comm)
b <- apply(comm, 1, function(x) {
x <- x/sum(x)
sum(outer(x,x) * fDist)
})
for(i in 2:nrow(trDiss)) {
# cat(i)
for(j in 1:(i-1)) {
trDiss[i,j] <- trDiss[j,i] <- rao(comm[i,], comm[j,], b[i], b[j], fDist)
}
trdivE <- mclapply(colnames(alps$spTrait), function(tr) {
trMat <- alps$spTrait[,tr,drop=FALSE]
trMat <- trMat[complete.cases(trMat),,drop=FALSE]
comm <- alps$siteSpecies[rows[[1]],which(colnames(alps$siteSpecies) %in% rownames(trMat))]
trMat <- trMat[which(rownames(trMat) %in% colnames(comm)),, drop=FALSE]
fDist <- as.matrix(dist(trMat))
trDiss <- matrix(nrow=nrow(comm), ncol=ncol(comm))
dimnames(trDiss) <- dimnames(comm)
b <- apply(comm, 1, function(x) {
x <- x/sum(x)
sum(outer(x,x) * fDist)
})
for(i in 2:nrow(trDiss)) {
# cat(i)
for(j in 1:(i-1)) {
trDiss[i,j] <- trDiss[j,i] <- rao(comm[i,], comm[j,], b[i], b[j], fDist)
}
trMPD <- mpd(comm, dis=fDist)
trDiss <- melt(trDiss, varnames=c('site1', 'site2'), value.name = paste0(tr, "Diss"))
trMPD <- melt(trMPD, varnames=c('site1', 'site2'), value.name = paste0(tr,"MPD"))
trdivE <- merge(trMPD, envMat, all.y=TRUE)
merge(trDiss, trdivE, all.y=TRUE)
})
str(trDivE)
str(trdivE)
lapply(trdivE, function(x) sum(is.na(x[,3])/5050))
dimnames(comm)
tr <- 'SLA'
trMat <- alps$spTrait[,tr,drop=FALSE]
trMat <- trMat[complete.cases(trMat),,drop=FALSE]
comm <- alps$siteSpecies[rows[[1]],which(colnames(alps$siteSpecies) %in% rownames(trMat))]
trMat <- trMat[which(rownames(trMat) %in% colnames(comm)),, drop=FALSE]
fDist <- as.matrix(dist(trMat))
trDiss <- matrix(nrow=nrow(comm), ncol=ncol(comm))
dimnames(trDiss) <- dimnames(comm)
b <- apply(comm, 1, function(x) {
x <- x/sum(x)
sum(outer(x,x) * fDist)
})
dimnames(comm)
dim(comm)
for(i in 2:nrow(trDiss)) {
# cat(i)
for(j in 1:(i-1)) {
trDiss[i,j] <- trDiss[j,i] <- rao(comm[i,], comm[j,], b[i], b[j], fDist)
}
for(i in 2:nrow(trDiss)) {
cat(i)
for(j in 1:(i-1)) {
trDiss[i,j] <- trDiss[j,i] <- rao(comm[i,], comm[j,], b[i], b[j], fDist)
}
trDiss[1:10,1:10]
dim(trDiss)
trMat <- alps$spTrait[,tr,drop=FALSE]
trMat <- trMat[complete.cases(trMat),,drop=FALSE]
comm <- alps$siteSpecies[rows[[1]],which(colnames(alps$siteSpecies) %in% rownames(trMat))]
trMat <- trMat[which(rownames(trMat) %in% colnames(comm)),, drop=FALSE]
fDist <- as.matrix(dist(trMat))
trDiss <- matrix(nrow=nrow(comm), ncol=nrow(comm))
rownames(trDiss) <- colnames(trDiss) <- rownames(comm)
b <- apply(comm, 1, function(x) {
x <- x/sum(x)
sum(outer(x,x) * fDist)
})
for(i in 2:nrow(trDiss)) {
cat(i)
for(j in 1:(i-1)) {
trDiss[i,j] <- trDiss[j,i] <- rao(comm[i,], comm[j,], b[i], b[j], fDist)
}
trMPD <- mpd(comm, dis=fDist)
trDiss_m <- melt(trDiss, varnames=c('site1', 'site2'), value.name = paste0(tr, "Diss"))
trMPD_m <- melt(trMPD, varnames=c('site1', 'site2'), value.name = paste0(tr,"MPD"))
trdivE <- merge(trMPD_m, envMat, all.y=TRUE)
test <- merge(trDiss_m, trdivE, all.y=TRUE)
HEAD(TEST)
head(test)
sum(is.na(test[,3]))
sum(is.na(test[,4]))
trdivE <- mclapply(colnames(alps$spTrait), function(tr) {
trMat <- alps$spTrait[,tr,drop=FALSE]
trMat <- trMat[complete.cases(trMat),,drop=FALSE]
comm <- alps$siteSpecies[rows[[1]],which(colnames(alps$siteSpecies) %in% rownames(trMat))]
trMat <- trMat[which(rownames(trMat) %in% colnames(comm)),, drop=FALSE]
fDist <- as.matrix(dist(trMat))
trDiss <- matrix(nrow=nrow(comm), ncol=nrow(comm))
rownames(trDiss) <- colnames(trDiss) <- rownames(comm)
b <- apply(comm, 1, function(x) {
x <- x/sum(x)
sum(outer(x,x) * fDist)
})
for(i in 2:nrow(trDiss)) {
# cat(i)
for(j in 1:(i-1)) {
trDiss[i,j] <- trDiss[j,i] <- rao(comm[i,], comm[j,], b[i], b[j], fDist)
}
trMPD <- mpd(comm, dis=fDist)
trDiss_m <- melt(trDiss, varnames=c('site1', 'site2'), value.name = paste0(tr, "Diss"))
trMPD_m <- melt(trMPD, varnames=c('site1', 'site2'), value.name = paste0(tr,"MPD"))
trdivE <- merge(trMPD_m, envMat, all.y=TRUE)
merge(trDiss_m, trdivE, all.y=TRUE)
}, mc.cores=4)
pdf("~/Desktop/plot.pdf")
par(mfrow=c(5,2))
lapply(trdivE, function(x){
plot(x[,'distance'], x[,3], pch=20, cex=0.5, main=colnames(x)[3])
lines(predict(loess(x[,3] ~ x[,'distance'])), col='blue', lwd=1.5)
plot(x[,'distance'], trMPDE[,4], pch=20, cex=0.5, main=colnames(x)[4])
lines(predict(loess(x[,4] ~ x[,'distance'])), col='blue', lwd=1.5)
})
dev.off()
pdf("~/Desktop/plot.pdf", width=12, h=6)
par(mfrow=c(2,5))
lapply(trdivE, function(x){
plot(x[,'distance'], x[,3], pch=20, cex=0.5, main=colnames(x)[3])
lines(predict(loess(x[,3] ~ x[,'distance'])), col='blue', lwd=1.5)
plot(x[,'distance'], trMPDE[,4], pch=20, cex=0.5, main=colnames(x)[4])
lines(predict(loess(x[,4] ~ x[,'distance'])), col='blue', lwd=1.5)
})
dev.off()
head(trdivE[[1]])
pdf("~/Desktop/plot.pdf", width=12, h=6)
par(mfrow=c(2,5))
lapply(trdivE, function(x){
plot(x[,'distance'], x[,3], pch=20, cex=0.5, main=colnames(x)[3])
lines(predict(loess(x[,3] ~ x[,'distance'])), col='blue', lwd=1.5)
plot(x[,'distance'], x[,4], pch=20, cex=0.5, main=colnames(x)[4])
lines(predict(loess(x[,4] ~ x[,'distance'])), col='blue', lwd=1.5)
})
dev.off()
pdf("~/Desktop/plot.pdf", width=12, h=6)
par(mfcol=c(2,5))
lapply(trdivE, function(x){
plot(x[,'distance'], x[,3], pch=20, cex=0.5, main=colnames(x)[3])
lines(predict(loess(x[,3] ~ x[,'distance'])), col='blue', lwd=1.5)
plot(x[,'distance'], x[,4], pch=20, cex=0.5, main=colnames(x)[4])
lines(predict(loess(x[,4] ~ x[,'distance'])), col='blue', lwd=1.5)
})
dev.off()
head(alps$spTrait)
table(rowSums(is.na(alps$spTrait)))
nrow(alps$spTrait)
table(rowSums(is.na(alps$spTrait[,-2])))
row <- which(complete.cases(alps$spTrait[,-2])
)
sps <- rownames(alps$spTrait)[rows]
sps <- rownames(alps$spTrait)[row]
sps
length(sps)
sum(sps %in% colnames(alps$siteSpecies))
row <- which(complete.cases(alps$spTrait[,-2])
)
head(alps$spTrait)
table(rowSums(is.na(alps$spTrait[,-1])))
cor(alps$spTrait)
?cor
cor(alps$spTrait, use="complete.obs")
hist(alps$spTrait[,'SLA'])
hist(alps$spTrait[,'PL_VEG_H'])
hist(alps$spTrait[,'SEEDM'])
hist(alps$spTrait[,'LDMC'])
hist(log(alps$spTrait[,'SEEDM']))
hist(log(alps$spTrait[,'PL_VEG_H']))
hist(log(alps$spTrait[,'SLA']))
head(spBeta)
taxBeta <- merge(spBeta, envMat)
head(taxBeta)
nrow(taxBeta)
nrow(spBeta)
nrow(envMat)
write.csv('3_alps/dat/tax-beta.csv')
write.csv(taxBeta,'3_alps/dat/tax-beta.csv')
library("mbmtools")
library("mbmdata")
library(reshape2)
data(alps)
# site selection
# keep all sites above 3000m, otherwise keep only sites with >5 releves
keep <- keep & (alps$siteEnv[,'num_releves'] >= 5 | alps$siteEnv[,'elev'] > 3000)
# choose a maximum of 9 sites from 250m elevational bands
get_rows <- function(minElev, maxElev, elev, n, mask) {
inds <- which(elev > minElev & elev <= maxElev & mask)
if(length(inds) <= n)
{
return(inds)
} else {
return(sample(inds, n))
}
elevBands <- seq(0,3500,250)
maxN <- ceiling(100 / (length(elevBands) - 1)) # 100 is the approx target final N; --> 9 per band
library("mbmtools")
library("mbmdata")
library(reshape2)
data(alps)
# site selection
# keep all sites above 3000m, otherwise keep only sites with >5 releves
keep <- (alps$siteEnv[,'num_releves'] >= 5 | alps$siteEnv[,'elev'] > 3000)
# choose a maximum of 9 sites from 250m elevational bands
get_rows <- function(minElev, maxElev, elev, n, mask) {
inds <- which(elev > minElev & elev <= maxElev & mask)
if(length(inds) <= n)
{
return(inds)
} else {
return(sample(inds, n))
}
elevBands <- seq(500,3500,250)
maxN <- ceiling(100 / (length(elevBands) - 1)) # 100 is the approx target final N; --> 9 per band
maxN
elevBands <- seq(0,3500,250)
maxN <- ceiling(100 / (length(elevBands) - 1)) # 100 is the approx target final N; --> 9 per band
maxN
rows <- unlist(mapply(get_rows, minElev=elevBands[1:(length(elevBands)-1)], maxElev=elevBands[2:length(elevBands)],
MoreArgs=list(elev=alps$siteEnv[,'elev'], n=maxN, mask=keep)))
rows
length(rows)
envVars <- c('bio_4', 'bio_6', 'bio_7', 'bio_15')
envMat <- env_dissim(alps$siteEnv[rows,envVars])
spBeta <- sorensen(alps$siteSpecies[rows,])
spBeta <- melt(spBeta,varnames=c('site1', 'site2'), value.name = 'sor')
taxBeta <- merge(spBeta, envMat)
head(taxBeta)
nrow(taxBeta)
ade4::is.euclid
sorensen <- function(comm, dis)
{
if(missing(dis))
return(sor(comm))
if((nrow(dis) != ncol(dis)) | (colnames(dis) != rownames(dis)))
stop("dis must be square with identical row and column names")
if(! all(rownames(dis) %in% colnames(comm))) {
warning("Some species in dis are not present in comm and will be dropped")
dis <- match_mat_dims(dis, comm, by.x = 'rc', by.y = 'c')
}
if(! all(colnames(comm) %in% rownames(dis))) {
warning("Some species in comm are not present in dis and will be dropped")
comm <- match_mat_dims(comm, dis, by.x='c')
}
# verify the distance matrix is euclidean
ev <- eigen(dis, symmetric=TRUE, only.values=TRUE)$values
w0 <- min(ev)/max(ev)
if(w0 < 0) stop("distance matrix must be euclidean")
sim <- 1 - dis
num <- matrix(nrow = nrow(comm), ncol=nrow(comm))
for(a in 1:nrow(comm)) {
for(b in a:nrow(comm)) {
num[a,b] <- sum(outer(comm[a,], comm[b,]) * sim)
}
num[lower.tri(num)] <- t(num)[lower.tri(num)]
denom <- outer(0.5*diag(num), 0.5*diag(num), '+')
1 - num/denom
}
alps$spTrait
trMat <- alps$spTrait
trMat <- trMat[,-2] # drop repro ht
sum(complete.cases(trMat))
trMat <- trMat[complete.cases(trMat),]
trMat
dim(trMat)
trDis <- dist(trMat)
trDis
dim(trDis)
trDis <- as.matrix(dist(trMat))
dim(trDis)
sorensen(alps$siteSpecies[rows,], trDis)
sorensen <- function(comm, dis)
{
if(missing(dis))
return(sor(comm))
if((nrow(dis) != ncol(dis)) | (colnames(dis) != rownames(dis)))
stop("dis must be square with identical row and column names")
if(! all(rownames(dis) %in% colnames(comm))) {
warning("Some species in dis are not present in comm and will be dropped")
dis <- mbmtools:::match_mat_dims(dis, comm, by.x = 'rc', by.y = 'c')
}
if(! all(colnames(comm) %in% rownames(dis))) {
warning("Some species in comm are not present in dis and will be dropped")
comm <- mbmtools:::match_mat_dims(comm, dis, by.x='c')
}
# verify the distance matrix is euclidean
ev <- eigen(dis, symmetric=TRUE, only.values=TRUE)$values
w0 <- min(ev)/max(ev)
if(w0 < 0) stop("distance matrix must be euclidean")
sim <- 1 - dis
num <- matrix(nrow = nrow(comm), ncol=nrow(comm))
for(a in 1:nrow(comm)) {
for(b in a:nrow(comm)) {
num[a,b] <- sum(outer(comm[a,], comm[b,]) * sim)
}
num[lower.tri(num)] <- t(num)[lower.tri(num)]
denom <- outer(0.5*diag(num), 0.5*diag(num), '+')
1 - num/denom
}
sorensen(alps$siteSpecies[rows,], trDis)
ev <- eigen(trDis)
length(ev)
length(ev$values)
range(ev$values)
ev$values
sorensen <- function(comm, dis)
{
if(missing(dis))
return(sor(comm))
if((nrow(dis) != ncol(dis)) | (colnames(dis) != rownames(dis)))
stop("dis must be square with identical row and column names")
if(! all(rownames(dis) %in% colnames(comm))) {
warning("Some species in dis are not present in comm and will be dropped")
dis <- mbmtools:::match_mat_dims(dis, comm, by.x = 'rc', by.y = 'c')
}
if(! all(colnames(comm) %in% rownames(dis))) {
warning("Some species in comm are not present in dis and will be dropped")
comm <- mbmtools:::match_mat_dims(comm, dis, by.x='c')
}
# verify the distance matrix is euclidean
# ev <- eigen(dis, symmetric=TRUE, only.values=TRUE)$values
# w0 <- min(ev)/max(ev)
# if(w0 < 0) stop("distance matrix must be euclidean")
sim <- 1 - dis
num <- matrix(nrow = nrow(comm), ncol=nrow(comm))
for(a in 1:nrow(comm)) {
for(b in a:nrow(comm)) {
num[a,b] <- sum(outer(comm[a,], comm[b,]) * sim)
}
num[lower.tri(num)] <- t(num)[lower.tri(num)]
denom <- outer(0.5*diag(num), 0.5*diag(num), '+')
1 - num/denom
}
sorensen(alps$siteSpecies[rows,], trDis) -> test
range(test)
range(trDist)
range(trDis)
sorensen(alps$siteSpecies[rows,], trDis/max(trDis)) -> test
if((nrow(dis) != ncol(dis)) | any((colnames(dis) != rownames(dis))))
stop("dis must be square with identical row and column names")
dis <- trDis
if((nrow(dis) != ncol(dis)) | any((colnames(dis) != rownames(dis))))
stop("dis must be square with identical row and column names")
rm(dis)
range(test)
trMat
trMat <- scale(trMat)
trDis <- as.matrix(dist(trMat))
trSor <- sorensen(alps$siteSpecies[rows,], trDis) ## this is still unacceptably slow, AND it is yielding negative values
range(trSor)
trDis <- trDis / max(trDis)
trSor <- sorensen(alps$siteSpecies[rows,], trDis) ## this is still unacceptably slow, AND it is yielding negative values
range(trSor)
all(diag(trSor) == 0)
library("mbmtools")
library("mbmdata")
library(reshape2)
data(alps)
# site selection
# keep all sites above 3000m, otherwise keep only sites with >5 releves
keep <- (alps$siteEnv[,'num_releves'] >= 5 | alps$siteEnv[,'elev'] > 3000)
# choose a maximum of 9 sites from 250m elevational bands
get_rows <- function(minElev, maxElev, elev, n, mask) {
inds <- which(elev > minElev & elev <= maxElev & mask)
if(length(inds) <= n)
{
return(inds)
} else {
return(sample(inds, n))
}
elevBands <- seq(0,3500,250)
maxN <- ceiling(100 / (length(elevBands) - 1)) # 100 is the approx target final N; --> 9 per band
# choose rows
rows <- unlist(mapply(get_rows, minElev=elevBands[1:(length(elevBands)-1)], maxElev=elevBands[2:length(elevBands)],
MoreArgs=list(elev=alps$siteEnv[,'elev'], n=maxN, mask=keep)))
# covariate prep
# include seaonality (bio4), min temp of coldest month (6), annual temp range (7), and precip seasonality(15)
envVars <- c('bio_4', 'bio_6', 'bio_7', 'bio_15')
envMat <- env_dissim(alps$siteEnv[rows,envVars])
spBeta <- sorensen(alps$siteSpecies[rows,])
devtools::install_local("~/work/projects/mbm/mbmtools")
library("mbmtools")
spBeta <- sorensen(alps$siteSpecies[rows,])
sorensen
devtools::install_local("~/work/projects/mbm/mbmtools")
spBeta <- sorensen(alps$siteSpecies[rows,])
spBeta <- melt(spBeta,varnames=c('site1', 'site2'), value.name = 'sor')
taxBeta <- merge(spBeta, envMat)
head(taxBeta)
plot(sor ~ distance, data=taxBeta, pch=20, cex-0.5)
plot(sor ~ distance, data=taxBeta, pch=20, cex=0.5)
trMat <- alps$spTrait
trMat <- trMat[,-2] # drop repro ht
trMat <- trMat[complete.cases(trMat),]
trMat <- scale(trMat)
trDis <- as.matrix(dist(trMat))
trDis <- trDis / max(trDis)
trSor <- sorensen(alps$siteSpecies[rows,], trDis) ## this is still unacceptably slow, AND it is yielding negative values unless the distances are scaled to be between 0 and 1
dim(trDis)
tim(trSor)
dim(trSor)
dim(alps$siteSpecies[rows,])
comm = alps$siteSpecies[rows,]
dis = trDis
range(dis)
if((nrow(dis) != ncol(dis)) | any((colnames(dis) != rownames(dis))))
stop("dis must be square with identical row and column names")
if(! all(rownames(dis) %in% colnames(comm))) {
warning("Some species in dis are not present in comm and will be dropped")
dis <- match_mat_dims(dis, comm, by.x = 'rc', by.y = 'c')
}
if(! all(colnames(comm) %in% rownames(dis))) {
warning("Some species in comm are not present in dis and will be dropped")
comm <- match_mat_dims(comm, dis, by.x='c')
}
dim(comm)
dim(dis)
comm <- match_mat_dims(comm, dis, by.x='c')
if(! all(rownames(dis) %in% colnames(comm))) {
warning("Some species in dis are not present in comm and will be dropped")
dis <- mbmtools:::match_mat_dims(dis, comm, by.x = 'rc', by.y = 'c')
}
if(! all(colnames(comm) %in% rownames(dis))) {
warning("Some species in comm are not present in dis and will be dropped")
comm <- mbmtools:::match_mat_dims(comm, dis, by.x='c')
}
dim(comm)
dim(dis)
match_mat_dims <- function(x, y, by.x = c('r', 'c', 'rc'), by.y = c('r', 'c'))
{
by.x <- match.arg(by.x)
by.y <- match.arg(by.y)
if(by.y == 'c') y <- t(y)
if(grepl('r', by.x))
{
ind <- match(rownames(y), rownames(x))
x <- x[ind,]
}
if(grepl('c', by.x))
{
ind <- match(rownames(y), colnames(x))
x <- x[,ind]
}
x
}
if(! all(colnames(comm) %in% rownames(dis))) {
warning("Some species in comm are not present in dis and will be dropped")
comm <- match_mat_dims(comm, dis, by.x='c')
}
dim(comm)
sim <- 1 - dis
num <- matrix(nrow = nrow(comm), ncol=nrow(comm))
for(a in 1:nrow(comm)) {
for(b in a:nrow(comm)) {
num[a,b] <- sum(outer(comm[a,], comm[b,]) * sim)
}
num[lower.tri(num)] <- t(num)[lower.tri(num)]
denom <- outer(0.5*diag(num), 0.5*diag(num), '+')
